import rethinkdb
# None r
rethinkdb.__doc__ = u'The toplevel RQL namespace.\n\nSetup your top level namespace.\n>>> import rethinkdb as r'
# r connect
rethinkdb.connect.__doc__ = u"Create a new connection to the database server.<br /><br />If the\nconnection cannot be established, a <code>RqlDriverError</code> exception will\nbe thrown.\n\n\nOpens a connection using the default host and port but specifying the default database.\n>>> conn = r.connect(db='heroes')"
# connection repl
rethinkdb.net.Connection.repl.__func__.__doc__ = u"Set the default connection to make REPL use easier. Allows calling\n<code>run()</code> without specifying a connection. <br/><br />\nConnection objects are not thread safe and <code>repl</code> connections\nshould not be used in multi-threaded environments.\n\n\nSet the default connection in REPL, and call `run()`\nwithout specifying the connection.\n\n>>> r.connect().repl()\nr.table('users').run()\n"
# connection close
rethinkdb.net.Connection.close.__func__.__doc__ = u'Close an open connection. Closing a connection cancels all outstanding\nrequests and frees the memory associated with the open requests.\n\n\nClose an open connection.\n>>> conn.close()'
# connection reconnect
rethinkdb.net.Connection.reconnect.__func__.__doc__ = u'Close and attempt to reopen a connection. Has the effect of canceling\nany outstanding request while keeping the connection open.\n\n\nCancel outstanding requests/queries that are no longer needed.\n>>> conn.reconnect()'
# connection use
rethinkdb.net.Connection.use.__func__.__doc__ = u"Change the default database on this connection.\n\nChange the default database so that we don't need\nto specify the database when referencing a table.\n\n>>> conn.use('heroes')"
# query run
rethinkdb.ast.RqlQuery.run.__func__.__doc__ = u'Run a query on a connection.\n\nCall run on the connection with a query to execute the query.\nThe callback will get a cursor from which results may be retrieved.\n\n>>> for doc in r.table(\'marvel\').run(conn):\n  print doc\n\n\nIf you are OK with potentially out of date data from all the tables\ninvolved in this query and want potentially faster reads, pass a flag\nallowing out of date data in an options object.  Settings for\nindividual tables will supercede this global setting for all tables\nin the query.\n\n>>> r.table(\'marvel\').run(conn, use_outdated=True)\n\nIf you just want to send a write and forget about it, you\ncan set `noreply` to true in the options.  In this case\n`run` will return immediately.\n\n>>> r.table(\'marvel\').run(conn, noreply=True)\n\nIf you want to specify whether to wait for a write to be\nwritten to disk (overriding the table\'s default settings),\nyou can set `durability` to `\'hard\'` or `\'soft\'` in the\noptions.\n\n>>> r.table(\'marvel\')\n .insert({ \'superhero\': \'Iron Man\', \'superpower\': \'Arc Reactor\' })\n .run(conn, noreply=True, durability=\'soft\')\n\n\nIf you do not want a time object to be converted to a native date object,\nyou can pass a time_format flag to prevent it (valid flags are "raw" and "native").\nThis query returns an object with two fields (epoch_time and $reql_type$)\ninstead of a native date object.\n\n>>> r.now().run(conn, time_format="raw")\n'
# cursor next
# cursor hasNext
rethinkdb.net.Cursor.hasNext.__func__.__doc__ = u'Check if there are more elements in the cursor.\n\nAre there more elements in the cursor?\n>>> var hasMore = cur.hasNext();'
# cursor each
# cursor toArray
rethinkdb.net.Cursor.toArray.__func__.__doc__ = u'Retrieve all results and pass them as an array to the given callback.\n\nFor small result sets it may be more convenient to process them at once as an array.\n>>> cur.toArray(function(err, results) {\n  for(var i in results) {\n    processRow(results[i]);\n  }\n});\n'
# cursor close-cursor
# connection addListener
rethinkdb.net.Connection.addListener.__func__.__doc__ = u"The connection object also supports the event emitter interface so you can listen for\nchanges in connection state.\n\n\nMonitor connection state with events 'connect', 'close', and 'error'.\n>>> r.connect({}, function(err, conn) {\n    if (err) throw err;\n\n    conn.addListener('error', function(e) {\n      processNetworkError(e);\n    });\n\n    conn.addListener('close', function() {\n      cleanup();\n    });\n\n    runQueries(conn);\n});\n\n\nAs in Node, 'on' is a synonym for 'addListener'.\n>>> conn.on('close', function() {\n    cleanup();\n});\n\nconn.close();\n"
# r db_create
rethinkdb.db_create.__doc__ = u"Create a database. A RethinkDB database is a collection of tables,\nsimilar to relational databases.<br /><br />If successful, the operation returns\nan object: <code>{created: 1}</code>. If a database with the same name already\nexists the operation throws <code>RqlRuntimeError</code>.<br/> Note:\nthat you can only use alphanumeric characters and underscores for the database name.\n\n\nCreate a database named 'superheroes'.\n>>> r.db_create('superheroes').run(conn)"
# r db_drop
rethinkdb.db_drop.__doc__ = u"Drop a database. The database, all its tables, and corresponding\ndata will be deleted.<br /><br />If successful, the operation returns the object\n<code>{dropped: 1}</code>. If the specified database doesn't exist a <code>RqlRuntimeError</code>\nis thrown.\n\n\nDrop a database named 'superheroes'.\n>>> r.db_drop('superheroes').run(conn)"
# r db_list
rethinkdb.db_list.__doc__ = u'List all database names in the system.<br /><br />\nThe result is a list of strings.\n\n\nList all databases.\n>>> r.db_list().run(conn)'
# db table_create
rethinkdb.ast.DB.table_create.__func__.__doc__ = u"Create a table. A RethinkDB table is a collection of JSON documents.\n<br /><br />If successful, the operation returns an object: <code>{created: 1}</code>.  If\na table with the same name already exists, the operation throws <code>RqlRuntimeError</code>.<br /> Note:\nthat you can only use alphanumeric characters and underscores for the table name.<br/>\n<br /><br />When creating a table you can specify the following options:\n<ul>\n<li><code>primary_key</code>(string): the name of the primary key. The default primary key is <code>id</code>;</li>\n<li><code>durability</code>(string): if set to <code>'soft'</code>, this enables <strong>soft durability</strong>\n on this table: writes will be acknowledged by the server immediately and flushed to disk in the background.\n Default is <code>'hard'</code> (acknowledgement of writes happens after data has been written to disk);</li>\n<li><code>cache_size</code>(number): set the cache size (in bytes) to be used by the table. The default is 1073741824 (1024MB);</li>\n<li><code>datacenter</code>(string): the name of the datacenter this table should be assigned to.</li>\n</ul>\n<br /><br />In Javascript, these options can use either the underscore or camelcase form (e.g. primaryKey, cacheSize).\n\n\nCreate a table named 'dc_universe' with the primary key set to field 'id'.\nIf a new document doesn't contain the field 'id', the database will\nautogenerate a value for it.\n\n>>> r.db('test').table_create('dc_universe').run(conn)\n\nCreate a table named 'dc_universe' using the field 'name'\nas primary key.\n\n>>> r.db('test').table_create('dc_universe', primary_key='name').run(conn)\n\nCreate a table to log the very fast actions of the heroes.\n\n>>> r.db('test').table_create('hero_actions', durability='soft').run(conn)"
# db table_drop
rethinkdb.ast.DB.table_drop.__func__.__doc__ = u"Drop a table. The table and all its data will be deleted.<br /><br\n/>If succesful, the operation returns an object: <code>{dropped: 1}</code>.\nIf the specified table doesn''t exist a <code>RqlRuntimeError</code> is thrown.\n\n\nDrop a table named 'dc_universe'.\n>>> r.db('test').table_drop('dc_universe').run(conn)"
# db table_list
rethinkdb.ast.DB.table_list.__func__.__doc__ = u"List all table names in a database.<br /><br />\nThe result is a list of strings.\n\n\nList all tables of the 'test' database.\n>>> r.db('test').table_list().run(conn)"
# table index_create
rethinkdb.ast.Table.index_create.__func__.__doc__ = u"Create a new secondary index on this table.\n\nTo efficiently query our heros by name we can create a secondary\nindex based on the value of that field. We can already quickly query\nheros by name with the primary index but to do the same based on hero\ncode names we'll have to create a secondary index based on that\nattribute.\n\n>>> r.table('dc').index_create('code_name').run(conn)\n\nYou can also create a secondary index based on an arbitrary function\non the document.\n\n>>> r.table('dc').index_create('power_rating',\n  lambda hero: hero['combat_power'] + (2 * hero['compassion_power'])\n).run(conn)\n\n\nA compound index can be created by returning an array of values to\nuse as the secondary index key.\n\n>>> r.table('dc').index_create('parental_planets',\n  lambda hero: [hero['mothers_home_planet'], hero['fathers_home_planet']]\n).run(conn)\n"
# table index_drop
rethinkdb.ast.Table.index_drop.__func__.__doc__ = u"Delete a previously created secondary index of this table.\n\nDrop a secondary index named 'code_name'.\n>>> r.table('dc').index_drop('code_name').run(conn)"
# table index_list
rethinkdb.ast.Table.index_list.__func__.__doc__ = u"List all the secondary indexes of this table.\n\nList the available secondary indexes for this table.\n>>> r.table('marvel').index_list().run(conn)"
# table insert
rethinkdb.ast.Table.insert.__func__.__doc__ = u"Insert JSON documents into a table. Accepts a single JSON\ndocument or an array of documents.  You may also pass the\noptional argument <code>durability</code> with value\n<code>'hard'</code> or <code>'soft'</code>, to override the\ntable or query's default durability setting, or the optional argument <code>return_vals</code>, which will return the value of the row you're inserting (and the old value if you use <code>upsert</code>) when set to true.<br/><br/>\nInsert returns an object that contains the following attributes:\n<ul>\n<li><code>inserted</code> - the number of documents that were succesfully inserted;</li>\n<li><code>replaced</code> - the number of documents that were updated when <code>upsert</code> is used;</li>\n<li><code>unchanged</code> - the number of documents that would have been modified, except that the new\nvalue was the same as the old value when doing an <code>upsert</code>;</li>\n<li><code>errors</code> - the number of errors encountered while inserting;</li>\n<li>if errors where encountered while inserting, <code>first_error</code> contains the text of the first error;</li>\n<li><code>generated_keys</code> - a list of generated primary key values;</li>\n<li><code>deleted</code> and <code>skipped</code>\n- <code>0</code> for an <code>insert</code> operation.</li>\n</ul>\n\n\nInsert a row into a table named 'marvel'.\n>>> r.table('marvel').insert(\n    { 'superhero': 'Iron Man', 'superpower':'Arc Reactor' }).run(conn)\n\n\nInsert multiple rows into a table named 'marvel'.  Also, specify that only soft durability is required.\n>>> r.table('marvel').insert([\n  { 'superhero': 'Wolverine', 'superpower': 'Adamantium' },\n  { 'superhero': 'Spiderman', 'superpower': 'spidy sense' }\n], durability='soft').run(conn)\n\n\nInsert a row into a table named 'marvel', overwriting if the document already exists.\n>>> r.table('marvel').insert(\n  { 'superhero': 'Iron Man', 'superpower': 'Arc Reactor' },\n  upsert=True\n).run(conn)\n\n\nGet back a copy of the new row, this is useful if you've done an upsert or generated an ID.\n>>> r.table('marvel').insert(\n  { 'superhero': 'Iron Man', 'superpower': 'Arc Reactor' },\n  upsert=True, return_vals=True\n).run(conn)\n"
# table update
rethinkdb.ast.Table.update.__func__.__doc__ = u"Update JSON documents in a table. Accepts a JSON document, a RQL\nexpression, or a combination of the two.  The optional argument\n<code>durability</code> with value <code>'hard'</code> or\n<code>'soft'</code> will override the table or query's default\ndurability setting.  The optional argument <code>return_vals</code> will return the old and new values of the row you're modifying when set to true (only valid for single-row updates).  The optional argument\n<code>non_atomic</code> lets you permit non-atomic updates.<br/><br/>\nUpdate returns an object that contains the following attributes:\n<ul>\n<li><code>replaced</code> - the number of documents that were updated;</li>\n<li><code>unchanged</code> - the number of documents that would have been modified\nexcept the new value was the same as the old value;</li>\n<li><code>skipped</code> - the number of documents that were left unmodified because\nthere was nothing to do: either the row didn't exist or the new value is null;</li>\n<li><code>errors</code> - the number of errors encountered while performing the update;</li>\n<li>if errors occured, <code>first_error</code> contains the text of the first error;</li>\n<li><code>deleted</code> and  <code>inserted</code>\n- <code>0</code> for an <code>update</code> operation.</li>\n</ul>\n\n\nUpdate Superman's age to 30. If attribute 'age' doesn't\nexist, adds it to the document.\n\n>>> r.table('marvel').get('superman').update({ 'age': 30 }).run(conn)\n\nIncrement every superhero's age. If age doesn't exist, throws an error.  Specify soft durability.\n\n>>> r.table('marvel').update(lambda x: {'age': x['age'] + 1}, durability='soft').run(conn)\n\nAllow the server to run non-atomic operations.\n>>> r.table('marvel').update(\n    lambda x: {'age': x['age'] + r.js('1')}, non_atomic=True).run(conn)\n\n\nYou can get back a copy of the original row and the update row using the return_vals flag.\n>>> r.table('marvel').get('superman').update({ 'age': 30 }, return_vals=True).run(conn)"
# table replace
rethinkdb.ast.Table.replace.__func__.__doc__ = u"Replace documents in a table. Accepts a JSON document or a RQL\nexpression, and replaces the original document with the new\none. The new document must have the same primary key as the\noriginal document.  The optional argument\n<code>durability</code> with value <code>'hard'</code> or\n<code>'soft'</code> will override the table or query's default\ndurability setting.  The optional argument <code>return_vals</code> will return the old and new values of the row you're modifying when set to true (only valid for single-row replacements).  The optional argument\n<code>non_atomic</code> lets you permit non-atomic updates.<br/><br/>\nReplace returns an object that contains the following attributes:\n<ul>\n<li><code>replaced</code> - the number of documents that were replaced;</li>\n<li><code>unchanged</code> - the number of documents that would have been modified,\nexcept that the new value was the same as the old value;</li>\n<li><code>inserted</code> - the number of new documents added. You can have new documents\ninserted if you do a point-replace on a key that isn't in the table or you do a replace\non a selection and one of the documents you are replacing has been deleted;</li>\n<li><code>deleted</code> - the number of deleted documents when doing a replace with null;</li>\n<li><code>errors</code> - the number of errors encountered while performing the replace;</li>\n<li>if errors occurred performing the replace, <code>first_error</code> contains the text of the first error encountered;</li>\n<li><code>skipped</code> - <code>0</code> for a <code>replace</code> operation.</li>\n</ul>\n\n\nRemove all existing attributes from Superman's document, and add an attribute 'age'.\n>>> r.table('marvel').get('superman').replace({ 'id': 'superman', 'age': 30 }).run(conn)\n\nAllow the server to run non-atomic operations.\n>>> r.table('marvel').get('superman').replace(\n    { 'id': 'superman', 'age': 30 }, non_atomic=True).run(conn)\n\n\nMark all Marvel heroes as favorites, specifying soft durability.\n>>> r.table('heroes').filter(r.row['universe'] == 'marvel').replace(\n    lambda hero: hero.merge({'is_fav': True}), durability='soft').run(conn)\n\n\nYou can get a copy of the previous value and the old value back using the <code>return_vals</code> flag.\n>>> r.table('heroes').filter(r.row['universe'] == 'marvel').replace(\n    lambda hero: hero.merge({'is_fav': True}), return_vals=True).run(conn)\n"
# table delete
rethinkdb.ast.Table.delete.__func__.__doc__ = u"Delete one or more documents from a table.  The optional argument <code>return_vals</code> will return the old value of the row you're deleting when set to true (only valid for single-row deletes).  The optional argument\n<code>durability</code> with value <code>'hard'</code> or\n<code>'soft'</code> will override the table or query's default\ndurability setting.<br/><br/>\nDelete returns an object that contains the following attributes:\n<ul>\n<li><code>deleted</code> - the number of documents that were deleted;</li>\n<li><code>skipped</code> - the number of documents from the selection that were left unmodified\nbecause there was nothing to do. For example, if you delete a row that has already been deleted,\nthat row will be skipped;</li>\n<li><code>errors</code> - the number of errors encountered while deleting;</li>\n<li>if errors occured, <code>first_error</code> contains the text of the first error;</li>\n<li><code>inserted</code>, <code>replaced</code>, and <code>unchanged</code> - all\n<code>0</code> for a <code>delete</code> operation.</li>\n</ul>\n\n\nDelete superman from the database.\n>>> r.table('marvel').get('superman').delete().run(conn)\n\nDelete every document from the table 'marvel'.  Also, don't wait for the operation to be flushed to disk.\n>>> r.table('marvel').delete(durability='soft').run(conn)\n\nYou can get back a copy of the row you delete from the database as well.\n>>> r.table('marvel').delete(return_vals=True).run(conn)"
# r db
rethinkdb.db.__doc__ = u"Reference a database.\n\nBefore we can query a table we have to select the correct database.\n>>> r.db('heroes').table('marvel').run(conn)"
# db table
rethinkdb.ast.DB.table.__func__.__doc__ = u"Select all documents in a table. This command can be chained with\nother commands to do further processing on the data.\n\n\nReturn all documents in the table 'marvel' of the default database.\n>>> r.table('marvel').run(conn)\n\nReturn all documents in the table 'marvel' of the database 'heroes'.\n>>> r.db('heroes').table('marvel').run(conn)\n\nIf you are OK with potentially out of date data\nfrom this table and want potentially faster reads, pass\na flag allowing out of date data.\n\n>>> r.db('heroes').table('marvel', True).run(conn)"
# table get
rethinkdb.ast.Table.get.__func__.__doc__ = u"Get a document by primary key.\n\nFind a document with the primary key 'superman'.\n>>> r.table('marvel').get('superman').run(conn)"
# table get_all
rethinkdb.ast.Table.get_all.__func__.__doc__ = u'Get all documents where the given value matches the value of the requested index.\n\nSecondary index keys are not guaranteed to be unique so we cannot\nquery via "get" when using a secondary index.\n\n>>> r.table(\'marvel\').get_all(\'man_of_steel\', index=\'code_name\').run(conn)\n\nWithout an index argument, we default to the primary index. While\n`get` will either return the document or `null` when no document\nwith such a primary key value exists, this will return either a one\nor zero length stream.\n\n>>> r.table(\'dc\').get_all(\'superman\').run(conn)\n\nYou can get multiple documents in a single call to `get_all`.\n\n>>> r.table(\'dc\').get_all(\'superman\', \'ant man\').run(conn)'
# table between
rethinkdb.ast.Table.between.__func__.__doc__ = u'Get all documents between two keys.  Accepts three optional arguments: `index`, `left_bound`, and `right_bound`.  If `index` is set to the name of a secondary index, `between` will return all documents where that index\'s value is in the specified range (it uses the primary key by default).  `left_bound` or `right_bound` may be set to `open` or `closed` to indicate whether or not to include that endpoint of the range (by default, `left_bound` is closed and `right_bound` is open).\n\n\nFind all users with primary key >= 10 and < 20 (a normal half-open interval).\n>>> r.table(\'marvel\').between(10, 20).run(conn)\n\nFind all users with primary key >= 10 and <= 20 (an interval closed on both sides).\n>>> r.table(\'marvel\').between(10, 20, right_bound=\'closed\').run(conn)\n\nFind all users with primary key < 20.  (You can use `NULL` to mean "unbounded" for either endpoint.)\n>>> r.table(\'marvel\').between(None, 20, right_bound=\'closed\').run(conn)\n\nBetween can be used on secondary indexes too. Just pass an optional index\nargument giving the secondary index to query.\n\n>>> r.table(\'dc\').between(\'dark_knight\', \'man_of_steel\', index=\'code_name\').run(conn)'
# sequence filter
rethinkdb.ast.RqlQuery.filter.__func__.__doc__ = u"Get all the documents for which the given predicate is true.<br\n/><br /> <code>filter</code> can be called on a sequence,\nselection, or a field containing an array of elements. The\nreturn type is the same as the type on which the function was\ncalled on.  The body of every filter is wrapped in an implicit\n`.default(false)`, and the default value can be changed by\npassing the optional argument `default`.  Setting this optional\nargument to `r.error()` will cause any non-existence errors to\nabort the filter.\n\n\nGet all active users aged 30.\n>>> r.table('users').filter({'active': True, 'profile': {'age': 30}}).run(conn)\n\nFilter supports the <code>r.literal</code> syntax if you want to get an exact match.\n>>> r.table('users').filter({'active': True, 'profile': r.literal({'age': 30})}).run(conn)\n\nSelect all documents where the 'magazines' field is greater than 5.\n>>> r.table('users').filter(r.row['magazines'] > 5).run(conn)\n\nSelect all documents where the 'abilities' embedded document has an attribute called 'super-strength'.\n>>> r.table('marvel').filter(\n    lambda hero: hero['abilities'].has_fields('super-strength')).run(conn)\n\n\nSelect all documents where the field 'powers' containing an array has an element equal to 10.\n>>> r.table('marvel').filter(\n  r.row['powers'].filter(lambda el: el == 10).count() > 0\n).run(conn)\n"
# sequence inner
rethinkdb.ast.RqlQuery.inner_join.__func__.__doc__ = u"Returns the inner product of two sequences (e.g. a table, a filter result) filtered by the predicate. The query compares each row of the left sequence with each row of the right sequence to find all pairs of rows which satisfy the predicate. When the predicate is satisfied, each matched pair of rows of both sequences are combined into a result row.\n\nConstruct a sequence of documents containing all cross-universe matchups where a marvel hero would lose.\n>>> r.table('marvel').inner_join(r.table('dc'), lambda marvelRow, dcRow: marvelRow['strength'] < dcRow['strength']).run(conn)"
# sequence outer
rethinkdb.ast.RqlQuery.outer_join.__func__.__doc__ = u"Computes a left outer join by retaining each row in the left table even if no match was found in the right table.\n\nConstruct a sequence of documents containing all cross-universe matchups where a marvel hero would lose, but keep marvel heroes who would never lose a matchup in the sequence.\n>>> r.table('marvel').outer_join(r.table('dc'),\n  lambda marvelRow, dcRow: marvelRow['strength'] < dcRow['strength']).run(conn)"
# sequence eqJoin
rethinkdb.ast.RqlQuery.eq_join.__func__.__doc__ = u"An efficient join that looks up elements in the right table by primary key.\n\nLet our heroes join forces to battle evil!\n>>> r.table('marvel').eq_join('main_dc_collaborator', r.table('dc')).run(conn)\n\nThe above query is equivalent to this inner join but runs in O(n log(m)) time rather than the O(n * m) time the inner join takes.\n>>> r.table('marvel').inner_join(r.table('dc'),\n  lambda left, right: left['main_dc_collaborator'] == right['hero_name']).run(conn)\n\nYou can take advantage of a secondary index on the second table by giving an optional index parameter.\n>>> r.table('marvel').eq_join('main_weapon_origin',\n    r.table('mythical_weapons'), index='origin').run(conn)\n\n\nYou can pass a function instead of an attribute to join on more complicated expressions. Here we join to the DC universe collaborator with whom the hero has the most appearances.\n>>> r.table('marvel').eq_join(lambda doc: doc['dc_collaborators'].order_by('appearances')[0]['name'],\n    r.table('dc')).run(conn)\n"
# stream zip
rethinkdb.ast.RqlQuery.zip.__func__.__doc__ = u"Used to 'zip' up the result of a join by merging the 'right' fields into 'left' fields of each member of the sequence.\n\n'zips up' the sequence by merging the left and right fields produced by a join.\n>>> r.table('marvel').eq_join('main_dc_collaborator', r.table('dc')).zip().run(conn)"
# sequence map
rethinkdb.ast.RqlQuery.map.__func__.__doc__ = u"Transform each element of the sequence by applying the given mapping function.\n\nConstruct a sequence of hero power ratings.\n>>> r.table('marvel').map(\n    lambda hero: hero['combatPower'] + hero['compassionPower'] * 2).run(conn)"
# sequence with_fields
rethinkdb.ast.RqlQuery.with_fields.__func__.__doc__ = u"Takes a sequence of objects and a list of fields.  If any objects in the sequence don't have all of the specified fields, they're dropped from the sequence.  The remaining objects have the specified fields plucked out.  (This is identical to `has_fields` followed by `pluck` on a sequence.)\n\nGet a list of heroes and their nemeses, excluding any heroes that lack one.\n>>> r.table('marvel').with_fields('id', 'nemesis')\n\nGet a list of heroes and their nemeses, excluding any heroes whose nemesis isn't in an evil organization.\n>>> r.table('marvel').with_fields('id', {'nemesis' : {'evil_organization' : True}})\n\nThe nested syntax can quickly become overly verbose so there's a shorthand.\n>>> r.table('marvel').with_fields('id', {'nemesis' : 'evil_organization'})"
# sequence concat_map
rethinkdb.ast.RqlQuery.concat_map.__func__.__doc__ = u"Flattens a sequence of arrays returned by the <code>mappingFunction</code> into a single sequence.\n\nConstruct a sequence of all monsters defeated by Marvel heroes. Here the field 'defeatedMonsters' is a list that is concatenated to the sequence.\n>>> r.table('marvel').concat_map(lambda hero: hero['defeatedMonsters']).run(conn)"
# sequence order_by
rethinkdb.ast.RqlQuery.order_by.__func__.__doc__ = u"Sort the sequence by document values of the given key(s).<br /><br /> <code>order by</code> defaults to ascending ordering. To explicitly specify the ordering, wrap the attribute with either <code>r.asc</code> or <code>r.desc</code>.\n\nOrder our heroes by a series of performance metrics.\n>>> r.table('marvel').order_by('enemies_vanquished', 'damsels_saved').run(conn)\n\nIndexes can be used to perform more efficient orderings. Notice that the index ordering always has highes precedence. Thus the following example is equivalent to the one above.\n>>> r.table('marvel').order_by('damsels_saved', index='enemies_vanquished').run(conn)\n\nYou can also specify a descending order when using an index.\n>>> r.table('marvel').order_by(index=r.desc('enemies_vanquished')).run(conn)\n\nLet's lead with our best vanquishers by specify descending ordering.\n>>> r.table('marvel').order_by(\n    r.desc('enemies_vanquished'), r.asc('damsels_saved')).run(conn)\n\nYou can use a function for ordering instead of just selecting an attribute.\n>>> r.table('marvel').order_by(lambda doc: doc['enemiesVanquished'] + doc['ramselsSaved']).run(conn)\n\nFunctions can also be used descendingly.\n>>> r.table('marvel').order_by(r.desc(lambda doc: doc['enemiesVanquished'] + doc['ramselsSaved'])).run(conn)"
# sequence skip
rethinkdb.ast.RqlQuery.skip.__func__.__doc__ = u"Skip a number of elements from the head of the sequence.\n\nHere in conjunction with `order_by` we choose to ignore the most successful heroes.\n>>> r.table('marvel').order_by('successMetric').skip(10).run(conn)"
# sequence limit
rethinkdb.ast.RqlQuery.limit.__func__.__doc__ = u"End the sequence after the given number of elements.\n\nOnly so many can fit in our Pantheon of heroes.\n>>> r.table('marvel').order_by('belovedness').limit(10).run(conn)"
# sequence slice
rethinkdb.ast.RqlQuery.__getitem__.__func__.__doc__ = u"Trim the sequence to within the bounds provided.\n\nFor this fight, we need heroes with a good mix of strength and agility.\n>>> r.table('marvel').order_by('strength')[5:10].run(conn)"
# sequence nth
rethinkdb.ast.RqlQuery.__getitem__.__func__.__doc__ = u'Get the nth element of a sequence.\n\nSelect the second element in the array.\n>>> r.expr([1,2,3])[1].run(conn)'
# sequence indexes_of
rethinkdb.ast.RqlQuery.indexes_of.__func__.__doc__ = u"Get the indexes of an element in a sequence. If the argument is a predicate, get the indexes of all elements matching it.\n\nFind the position of the letter 'c'.\n>>> r.expr(['a','b','c']).indexes_of('c').run(conn)\n\nFind the popularity ranking of invisible heroes.\n>>> r.table('marvel').union(r.table('dc')).order_by('popularity').indexes_of(\n  r.row['superpowers'].contains('invisibility')\n).run(conn)"
# sequence is_empty
rethinkdb.ast.RqlQuery.is_empty.__func__.__doc__ = u"Test if a sequence is empty.\n\nAre there any documents in the marvel table?\n>>> r.table('marvel').is_empty().run(conn)"
# sequence union
rethinkdb.ast.RqlQuery.union.__func__.__doc__ = u"Concatenate two sequences.\n\nConstruct a stream of all heroes.\n>>> r.table('marvel').union(r.table('dc')).run(conn)"
# sequence sample
rethinkdb.ast.RqlQuery.sample.__func__.__doc__ = u"Select a given number of elements from a sequence with uniform random\ndistribution. Selection is done without replacement.\n\n\nSelect 3 random heroes.\n>>> r.table('marvel').sample(3).run(conn)"
# sequence reduce
rethinkdb.ast.RqlQuery.reduce.__func__.__doc__ = u"Produce a single value from a sequence through repeated application\nof a reduction function.<br /><br />\nThe <code>reduce</code> function gets invoked repeatedly not only\nfor the input values but also for results of previous reduce invocations.\nThe type and format of the object that is passed in to reduce must be\nthe same with the one returned from reduce.\n\n\nHow many enemies have our heroes defeated?\n>>> r.table('marvel').map(r.row['monstersKilled']).reduce(\n    lambda acc, val: acc + val, 0).run(conn)"
# sequence count
# sequence distinct
rethinkdb.ast.RqlQuery.distinct.__func__.__doc__ = u"Remove duplicate elements from the sequence.\n\nWhich unique villains have been vanquished by marvel heroes?\n>>> r.table('marvel').concat_map(lambda hero: hero['villainList']).distinct().run(conn)"
# sequence groupedmapreduce
rethinkdb.ast.RqlQuery.grouped_map_reduce.__func__.__doc__ = u"Partition the sequence into groups based on the <code>grouping</code> function. The elements of each group are then mapped using the <code>mapping</code> function and reduced using the <code>reduction</code> function.<br /><br /><code>grouped_map_reduce</code> is a generalized form of <code>group by</code>.\n\nIt's only fair that heroes be compared against their weight class.\n>>> r.table('marvel').grouped_map_reduce(\n  lambda hero: hero['weightClass'],  # grouping\n  lambda hero: hero.pluck('name', 'strength'),  # mapping\n  lambda acc, hero: r.branch(acc['strength'] < hero['strength'], hero, acc),\n  {'name':'none', 'strength':0}  # base\n).run(conn)"
# sequence group_by
rethinkdb.ast.RqlQuery.group_by.__func__.__doc__ = u"Groups elements by the values of the given attributes and then applies the given reduction. Though similar to <code>grouped_map_reduce</code>, groupby takes a standardized object for specifying the reduction. Can be used with a number of predefined common reductions.\n\nUsing a predefined reduction we can easily find the average strength of members of each weight class.\n>>> r.table('marvel').group_by('weightClass', r.avg('strength')).run(conn)\n\nGroupings can also be specified on nested attributes.\n>>> r.table('marvel').group_by({'abilities' : {'primary' : True}}, r.avg('strength')).run(conn)\n\nThe nested syntax can quickly become verbose so there's a shortcut.\n>>> r.table('marvel').group_by({'abilities' : 'primary'}, r.avg('strength')).run(conn)"
# sequence contains
rethinkdb.ast.RqlQuery.contains.__func__.__doc__ = u"Returns whether or not a sequence contains all the specified values, or if functions are provided instead, returns whether or not a sequence contains values matching all the specified functions.\n\nHas Iron Man ever fought Superman?\n>>> r.table('marvel').get('ironman')['opponents'].contains('superman').run(conn)\n\nHas Iron Man ever defeated Superman in battle?\n>>> r.table('marvel').get('ironman')['battles'].contains(lambda battle: (battle['winner'] == 'ironman') & (battle['loser'] == 'superman'))\n"
# r count
# r sum
rethinkdb.sum.__doc__ = u"Compute the sum of the given field in the group.\n\nHow many enemies have been vanquished by heroes at each strength level?\n>>> r.table('marvel').group_by('strength', r.sum('enemiesVanquished')).run(conn)"
# r avg
rethinkdb.avg.__doc__ = u"Compute the average value of the given attribute for the group.\n\nWhat's the average agility of heroes at each strength level?\n>>> r.table('marvel').group_by('strength', r.avg('agility')).run(conn)"
# r row
rethinkdb.row.__doc__ = u"Returns the currently visited document.\n\nGet all users whose age is greater than 5.\n>>> r.table('users').filter(r.row['age'] > 5).run(conn)\n\nAccessing the attribute 'child' of an embedded document.\n>>> r.table('users').filter(r.row['embedded_doc']['child'] > 5).run(conn)\n\nAdd 1 to every element of an array.\n>>> r.expr([1, 2, 3]).map(r.row + 1).run(conn)\n\nFor nested queries functions should be used instead of r.row.\n>>> r.table('users').filter(\n    lambda doc: doc['name'] == r.table('prizes').get('winner')).run(conn)"
# sequence pluck
rethinkdb.ast.RqlQuery.pluck.__func__.__doc__ = u"Plucks out one or more attributes from either an object or a sequence of objects (projection).\n\nWe just need information about IronMan's reactor and not the rest of the document.\n>>> r.table('marvel').get('IronMan').pluck('reactorState', 'reactorPower').run(conn)\n\nFor the hero beauty contest we only care about certain qualities.\n>>> r.table('marvel').pluck('beauty', 'muscleTone', 'charm').run(conn)\n\nPluck can also be used on nested objects.\n>>> r.table('marvel').pluck({'abilities' : {'damage' : True, 'mana_cost' : True}, 'weapons' : True}).run(conn)\n\nThe nested syntax can quickly become overly verbose so there's a shorthand for it.\n>>> r.table('marvel').pluck({'abilities' : ['damage', 'mana_cost']}, 'weapons').run(conn)"
# sequence without
rethinkdb.ast.RqlQuery.without.__func__.__doc__ = u"The opposite of pluck; takes an object or a sequence of objects, and returns them with the specified paths removed.\n\nSince we don't need it for this computation we'll save bandwidth and leave out the list of IronMan's romantic conquests.\n>>> r.table('marvel').get('IronMan').without('personalVictoriesList').run(conn)\n\nWithout their prized weapons, our enemies will quickly be vanquished.\n>>> r.table('enemies').without('weapons').run(conn)\n\nNested objects can be used to remove the damage subfield from the weapons and abilities fields.\n>>> r.table('marvel').without({'weapons' : {'damage' : True}, 'abilities' : {'damage' : True}}).run(conn)\n\nThe nested syntax can quickly become overly verbose so there's a shorthand for it.\n>>> r.table('marvel').without({'weapons' : 'damage', 'abilities' : 'damage'}).run(conn)"
# singleSelection merge
rethinkdb.ast.RqlQuery.merge.__func__.__doc__ = u"Merge two objects together to construct a new object with properties from both. Gives preference to attributes from other when there is a conflict.\n\nEquip IronMan for battle.\n>>> r.table('marvel').get('IronMan').merge(\n  r.table('loadouts').get('alienInvasionKit')).run(conn)\n\n<code>Merge</code> can be used recursively to modify object within objects.\n>>> r.expr({'weapons' : {'spectacular graviton beam' : {'dmg' : 10, 'cooldown' : 20}}}).merge(\n  {'weapons' : {'spectacular graviton beam' : {'dmg' : 10}}}).run(conn)\n\nTo replace a nested object with another object you can use the <code>literal</code> keyword.\n>>> r.expr({'weapons' : {'spectacular graviton beam' : {'dmg' : 10, 'cooldown' : 20}}}).merge(\n  {'weapons' : r.literal({'repulsor rays' : {'dmg' : 3, 'cooldown' : 0}})}).run(conn)\n\n<code>Literal</code> can be used to remove keys from an object as well.\n>>> r.expr({'weapons' : {'spectacular graviton beam' : {'dmg' : 10, 'cooldown' : 20}}}).merge(\n  {'weapons' : {'spectacular graviton beam' : r.literal()}}).run(conn)"
# array append
rethinkdb.ast.RqlQuery.append.__func__.__doc__ = u"Append a value to an array.\n\nRetrieve Iron Man's equipment list with the addition of some new boots.\n>>> r.table('marvel').get('IronMan')['equipment'].append('newBoots').run(conn)"
# array prepend
rethinkdb.ast.RqlQuery.prepend.__func__.__doc__ = u"Prepend a value to an array.\n\nRetrieve Iron Man's equipment list with the addition of some new boots.\n>>> r.table('marvel').get('IronMan')['equipment'].prepend('newBoots').run(conn)"
# array difference
rethinkdb.ast.RqlQuery.difference.__func__.__doc__ = u"Remove the elements of one array from another array.\n\nRetrieve Iron Man's equipment list without boots.\n>>> r.table('marvel').get('IronMan')['equipment'].difference(['Boots']).run(conn)"
# array set_insert
rethinkdb.ast.RqlQuery.set_insert.__func__.__doc__ = u"Add a value to an <code>array</code> and return it as a <code>set</code>\n(an <code>array</code> with distinct values).\n\n\nRetrieve Iron Man's equipment list with the addition of some new boots.\n>>> r.table('marvel').get('IronMan')['equipment'].set_insert('newBoots').run(conn)"
# array set_union
rethinkdb.ast.RqlQuery.set_union.__func__.__doc__ = u"Add a several values to an <code>array</code> and return it as a\n<code>set</code> (an <code>array</code> with distinct values).\n\n\nRetrieve Iron Man's equipment list with the addition of some new\nboots and an arc reactor.\n\n>>> r.table('marvel').get('IronMan')['equipment'].set_union(['newBoots', 'arc_reactor']).run(conn)"
# array set_intersection
rethinkdb.ast.RqlQuery.set_intersection.__func__.__doc__ = u"Intersect two <code>arrays</code> returning values that occur in both of\nthem as a <code>set</code> (an <code>array</code> with distinct values).\n\n\nCheck which pieces of equipment Iron Man has from a fixed list.\n>>> r.table('marvel').get('IronMan')['equipment'].set_intersection(['newBoots', 'arc_reactor']).run(conn)"
# array set_difference
rethinkdb.ast.RqlQuery.set_difference.__func__.__doc__ = u"Remove the elements of one array from another and return them as a\n<code>set</code> (an <code>array</code> with distinct values).\n\n\nCheck which pieces of equipment Iron Man has, excluding a fixed list.\n>>> r.table('marvel').get('IronMan')['equipment'].set_difference(['newBoots', 'arc_reactor']).run(conn)"
# sequence get_field
rethinkdb.ast.RqlQuery.__getitem__.__func__.__doc__ = u"Get a single field from an object.  If called on a sequence, gets that field from every object in the sequence, skipping objects that lack it.\n\nWhat was Iron Man's first appearance in a comic?\n>>> r.table('marvel').get('IronMan')['firstAppearance'].run(conn)"
# sequence has_fields
rethinkdb.ast.RqlQuery.has_fields.__func__.__doc__ = u'Test if an object has all of the specified fields.  An object has a field if it has the specified key and that key maps to a non-null value.  For instance, the object `{\'a\':1,\'b\':2,\'c\':null}` has the fields `a` and `b`.\n\nWhich heroes are married?\n>>> r.table(\'marvel\').has_fields(\'spouse\').run(conn)\n\nTest if a single object has a field.\n>>> r.table(\'marvel\').get("IronMan").has_fields(\'spouse\').run(conn)\n\nYou can also test if nested fields exist to get only spouses with powers of their own.\n>>> r.table(\'marvel\').has_fields({\'spouse\' : {\'powers\' : True}}).run(conn)\n\nThe nested syntax can quickly get verbose so there\'s a shorthand.\n>>> r.table(\'marvel\').has_fields({\'spouse\' : \'powers\'}).run(conn)'
# array insert_at
rethinkdb.ast.RqlQuery.insert_at.__func__.__doc__ = u'Insert a value in to an array at a given index. Returns the modified array.\n\nHulk decides to join the avengers.\n>>> r.expr(["Iron Man", "Spider-Man"]).insert_at(1, "Hulk").run(conn)'
# array splice_at
rethinkdb.ast.RqlQuery.splice_at.__func__.__doc__ = u'Insert several values in to an array at a given index. Returns the modified array.\n\nHulk and Thor decide to join the avengers.\n>>> r.expr(["Iron Man", "Spider-Man"]).splice_at(1, ["Hulk", "Thor"]).run(conn)'
# array delete_at
rethinkdb.ast.RqlQuery.delete_at.__func__.__doc__ = u'Remove an element from an array at a given index. Returns the modified array.\n\nHulk decides to leave the avengers.\n>>> r.expr(["Iron Man", "Hulk", "Spider-Man"]).delete_at(1).run(conn)\n\nHulk and Thor decide to leave the avengers.\n>>> r.expr(["Iron Man", "Hulk", "Thor", "Spider-Man"]).delete_at(1,3).run(conn)'
# array change_at
rethinkdb.ast.RqlQuery.change_at.__func__.__doc__ = u'Change a value in an array at a given index. Returns the modified array.\n\nBruce Banner hulks out.\n>>> r.expr(["Iron Man", "Bruce", "Spider-Man"]).change_at(1, "Hulk").run(conn)'
# singleSelection keys
rethinkdb.ast.RqlQuery.keys.__func__.__doc__ = u"Return an array containing all of the object's keys.\n\nGet all the keys of a row.\n>>> r.table('marvel').get('ironman').keys().run(conn)"
# number add
rethinkdb.ast.RqlQuery.__add__.__func__.__doc__ = u'Sum two numbers, concatenate two strings, or concatenate 2 arrays.\n\nIt\'s as easy as 2 + 2 = 4.\n>>> (r.expr(2) + 2).run(conn)\n\nStrings can be concatenated too.\n>>> (r.expr("foo") + "bar").run(conn)\n\nArrays can be concatenated too.\n>>> (r.expr(["foo", "bar"]) + ["buzz"]).run(conn)\n\nCreate a date one year from now.\n>>> r.now() + 365*24*60*60'
# number sub
rethinkdb.ast.RqlQuery.__sub__.__func__.__doc__ = u"Subtract two numbers.\n\nIt's as easy as 2 - 2 = 0.\n>>> (r.expr(2) - 2).run(conn)\n\nCreate a date one year ago today.\n>>> r.now() - 365*24*60*60\n\nRetrieve how many seconds elapsed between today and date\n>>> r.now() - date"
# number mul
rethinkdb.ast.RqlQuery.__mul__.__func__.__doc__ = u'Multiply two numbers, or make a periodic array.\n\nIt\'s as easy as 2 * 2 = 4.\n>>> (r.expr(2) * 2).run(conn)\n\nArrays can be multiplied by numbers as well.\n>>> (r.expr(["This", "is", "the", "song", "that", "never", "ends."]) * 100).run(conn)'
# number div
rethinkdb.ast.RqlQuery.__div__.__func__.__doc__ = u"Divide two numbers.\n\nIt's as easy as 2 / 2 = 1.\n>>> (r.expr(2) / 2).run(conn)"
# number mod
rethinkdb.ast.RqlQuery.__mod__.__func__.__doc__ = u"Find the remainder when dividing two numbers.\n\nIt's as easy as 2 % 2 = 0.\n>>> (r.expr(2) % 2).run(conn)"
# bool and
rethinkdb.ast.RqlQuery.__and__.__func__.__doc__ = u'Compute the logical and of two values.\n\nTrue and false anded is false?\n>>> (r.expr(True) & False).run(conn)'
# bool or
rethinkdb.ast.RqlQuery.__or__.__func__.__doc__ = u'Compute the logical or of two values.\n\nTrue or false ored is true?\n>>> (r.expr(True) | False).run(conn)'
# value eq
rethinkdb.ast.RqlQuery.__eq__.__func__.__doc__ = u'Test if two values are equal.\n\nDoes 2 equal 2?\n>>> (r.expr(2) == 2).run(conn)'
# value ne
rethinkdb.ast.RqlQuery.__neq__.__func__.__doc__ = u'Test if two values are not equal.\n\nDoes 2 not equal 2?\n>>> (r.expr(2) != 2).run(conn)'
# value gt
rethinkdb.ast.RqlQuery.__gt__.__func__.__doc__ = u'Test if the first value is greater than other.\n\nIs 2 greater than 2?\n>>> (r.expr(2) > 2).run(conn)'
# value ge
rethinkdb.ast.RqlQuery.__ge__.__func__.__doc__ = u'Test if the first value is greater than or equal to other.\n\nIs 2 greater than or equal to 2?\n>>> (r.expr(2) >= 2).run(conn)'
# value lt
rethinkdb.ast.RqlQuery.__lt__.__func__.__doc__ = u'Test if the first value is less than other.\n\nIs 2 less than 2?\n>>> (r.expr(2) < 2).run(conn)'
# value le
rethinkdb.ast.RqlQuery.__le__.__func__.__doc__ = u'Test if the first value is less than or equal to other.\n\nIs 2 less than or equal to 2?\n>>> (r.expr(2) <= 2).run(conn)'
# bool not
rethinkdb.ast.RqlQuery.__not__.__func__.__doc__ = u'Compute the logical inverse (not).\n\nNot true is false.\n>>> (~r.expr(True)).run(conn)'
# string match
rethinkdb.ast.RqlQuery.match.__func__.__doc__ = u'Match against a regular expression.  Returns a match object containing the matched string, that string\'s start/end position, and the capture groups.  Accepts RE2 syntax (https://code.google.com/p/re2/wiki/Syntax).  You can enable case-insensitive matching by prefixing the regular expression with `(?i)`.  (See linked RE2 documentation for more flags.)\n\nGet all users whose name starts with A.\n>>> r.table(\'users\').filter(lambda row:row[\'name\'].match("^A")).run(conn)\n\nParse out a name (returns "mlucy").\n>>> r.expr(\'id:0,name:mlucy,foo:bar\').match(\'name:(\\w+)\')[\'groups\'][0][\'str\'].run(conn)\n\nFail to parse out a name (returns null).\n>>> r.expr(\'id:0,foo:bar\').match(\'name:(\\w+)\')[\'groups\'][0][\'str\'].run(conn)'
# r now
rethinkdb.now.__func__.__doc__ = u'\nReturn a time object representing the current time in UTC. The\ncommand <code>now()</code> is computed once when the server\nreceives the query, so multiple instances of\n<code>r.now()</code> will always return the same time inside a\nquery.\n\n\nAdd a new user with the time at which he subscribed.\n>>> r.table("users").insert({\n  "name": "John",\n  "subscription_date": r.now()\n}).run(conn)\n'
# r time
rethinkdb.time.__func__.__doc__ = u'Create a time object for a specific time.\n\n\nUpdate the birthdate of the user "John" to November 3rd, 1986 UTC.\n>>> r.table("user").get("John").update({"birthdate": r.time(1986, 11, 3, \'Z\')}).run(conn)\n'
# r epoch_time
rethinkdb.epoch_time.__func__.__doc__ = u'Create a time object based on seconds since epoch.\n\n\nUpdate the birthdate of the user "John" to November 3rd, 1986.\n>>> r.table("user").get("John").update({"birthdate": r.epoch_time(531360000)}).run(conn)\n'
# r iso8601
rethinkdb.iso8601.__func__.__doc__ = u'\nCreate a time object based on an iso8601 date-time string\n(e.g. \'2013-01-01T01:01:01+00:00\'). We support all valid ISO\n8601 formats except for week dates.  If you pass an ISO 8601\ndate-time without a time zone, you must specify the time zone\nwith the optarg `default_timezone`.  Read\nmore about the ISO 8601 format on the <a href="http://en.wikipedia.org/wiki/ISO_8601">Wikipedia page</a>.\n\n\nUpdate the time of John\'s birth.\n>>> r.table("user").get("John").update({"birth": r.iso8601(\'1986-11-03T08:30:00-07:00\')}).run(conn)\n'
# time in_timezone
rethinkdb.ast.RqlQuery.in_timezone.__func__.__doc__ = u"Return a new time object with a different timezone. While the time stays the same,\nthe results returned by methods such as <code>hours()</code> will change since they take the\ntimezone into account.\nThe timezone argument has to be of the ISO 8601 format.\n\n\nHour of the day in San Francisco (UTC/GMT -8, without daylight saving time).\n>>> r.now().in_timezone('-08:00').hours().run(conn)\n"
# time timezone
rethinkdb.ast.RqlQuery.timezone.__func__.__doc__ = u'Return the timezone of the time object.\n\n\nReturn all the users in the "-07:00" timezone.\n>>> r.table("users").filter( lambda user:\n  user["subscriptionDate"].timezone() == "-07:00"\n)\n'
# time during
rethinkdb.ast.RqlQuery.during.__func__.__doc__ = u'Return if a time is between two other times (by default, inclusive for the start, exclusive for the end).\n\n\nRetrieve all the posts that were posted between December 1st, 2013 (inclusive) and December 10th, 2013 (exclusive).\n>>> r.table("posts").filter(\n    r.row[\'date\'].during(r.time(2013, 12, 1), r.time(2013, 12, 10))\n).run(conn)\n\n\nRetrieve all the posts that were posted between December 1st, 2013 (exclusive) and December 10th, 2013 (inclusive).\n>>> r.table("posts").filter(\n  r.row[\'date\'].during(r.time(2013, 12, 1), r.time(2013, 12, 10), left_bound="open", right_bound="closed")\n).run(conn)\n'
# time date
rethinkdb.ast.RqlQuery.date.__func__.__doc__ = u'Return a new time object only based on the day, month and year (ie. the same day at 00:00).\n\n\nRetrieve all the users whose birthday is today\n>>> r.table("users").filter(lambda user:\n  user["birthdate"].date() == r.now().date()\n).run(conn)\n'
# time time_of_day
rethinkdb.ast.RqlQuery.time_of_day.__func__.__doc__ = u'Return the number of seconds elapsed since the beginning of the day stored in the time object.\n\n\nRetrieve posts that were submitted before noon.\n>>> r.table("posts").filter(\n    r.row["date"].time_of_day() <= 12*60*60\n).run(conn)\n'
# time year
rethinkdb.ast.RqlQuery.year.__func__.__doc__ = u'Return the year of a time object.\n\n\nRetrieve all the users born in 1986.\n>>> r.table("users").filter(lambda user:\n  user["birthdate"].year() == 1986\n).run(conn)\n'
# time month
rethinkdb.ast.RqlQuery.month.__func__.__doc__ = u'Return the month of a time object as a number between 1 and 12.\nFor your convenience, the terms <code>r.january</code>, <code>r.february</code> etc. are defined and map\nto the appropriate integer.\n\n\nRetrieve all the users who were born in November.\n>>> r.table("users").filter(\n  r.row["birthdate"].month() == 11\n)\n\n\nRetrieve all the users who were born in November.\n>>> r.table("users").filter(\n  r.row["birthdate"].month() == r.november\n)\n'
# time day
rethinkdb.ast.RqlQuery.day.__func__.__doc__ = u'Return the day of a time object as a number between 1 and 31.\n\n\nReturn the users born on the 24th of any month.\n>>> r.table("users").filter(\n  r.row["birthdate"].day() == 24\n)\n'
# time day_of_week
rethinkdb.ast.RqlQuery.day_of_week.__func__.__doc__ = u'Return the day of week of a time object as a number between 1 and 7 (following ISO 8601 standard).\nFor your convenience, the terms <code>r.monday</code>, <code>r.tuesday</code> etc. are defined and map\nto the appropriate integer.\n\n\nReturn today\'s day of week.\n>>> r.now().day_of_week().run(conn)\n\n\nRetrieve all the users who were born on a Tuesday.\n>>> r.table("users").filter(\n  r.row["birthdate"].day_of_week() == r.tuesday\n)\n'
# time day_of_year
rethinkdb.ast.RqlQuery.day_of_year.__func__.__doc__ = u'Return the day of the year of a time object as a number between 1 and 366 (following ISO 8601 standard).\n\n\nRetrieve all the users who were born the first day of a year.\n>>> r.table("users").filter(\n  r.row["birthdate"].day_of_year() == 1\n)\n'
# time hours
rethinkdb.ast.RqlQuery.hours.__func__.__doc__ = u'Return the hour in a time object as a number between 0 and 23.\n\n\nReturn all the posts submitted after midnight and before 4am.\n>>> r.table("posts").filter(lambda post:\n    post["date"].hours() < 4\n)\n'
# time minutes
rethinkdb.ast.RqlQuery.minutes.__func__.__doc__ = u'Return the minute in a time object as a number between 0 and 59.\n\n\nReturn all the posts submitted during the first 10 minutes of every hour.\n>>> r.table("posts").filter(lambda post:\n    post["date"].minutes() < 10\n)\n'
# time seconds
rethinkdb.ast.RqlQuery.seconds.__func__.__doc__ = u'Return the seconds in a time object as a number between 0 and 59.999 (double precision).\n\n\nReturn the post submitted during the first 30 seconds of every minute.\n>>> r.table("posts").filter(lambda post:\n    post["date"].seconds() < 30\n)\n'
# time to_iso8601
rethinkdb.ast.RqlQuery.to_iso8601.__func__.__doc__ = u'Convert a time object to its iso 8601 format.\n\n\nReturn the current time in an ISO8601 format.\n>>> r.now().to_iso8601()\n'
# time to_epoch_time
rethinkdb.ast.RqlQuery.to_epoch_time.__func__.__doc__ = u'Convert a time object to its epoch time.\n\n\nReturn the current time in an ISO8601 format.\n>>> r.now().to_epoch_time()\n'
# any do
rethinkdb.ast.RqlQuery.do.__doc__ = u"Evaluate the <code>expr</code> in the context of one or more value\nbindings.<br /><br />\nThe type of the result is the type of the value returned from <code>expr</code>.\n\n\nThe object(s) passed to do() can be bound to name(s). The last argument is the expression to evaluate in the context of the bindings.\n>>> r.do(r.table('marvel').get('IronMan'),\n     lambda ironman: ironman['name']).run(conn)"
# r branch
rethinkdb.branch.__doc__ = u"Evaluate one of two control paths based on the value of an expression. \n<code>branch</code> is effectively an <code>if</code> renamed due to\nlanguage constraints.<br /><br />\nThe type of the result is determined by the type of the branch that\ngets executed.\n\n\nReturn the manlier of two heroes:\n>>> r.table('marvel').map(r.branch(r.row['victories'] > 100,\n    r.row['name'] + ' is a superhero',\n    r.row['name'] + ' is a hero')\n).run(conn)"
# sequence foreach
rethinkdb.ast.RqlQuery.for_each.__func__.__doc__ = u"Loop over a sequence, evaluating the given write query for each element.\n\nNow that our heroes have defeated their villains, we can safely remove them from the villain table.\n>>> r.table('marvel').for_each(\n    lambda hero: r.table('villains').get(hero['villainDefeated']).delete()\n).run(conn)"
# r error
rethinkdb.error.__doc__ = u"Throw a runtime error.  If called with no arguments inside the second argument to `default`, re-throw the current error.\n\nIron Man can't possibly have lost a battle:\n>>> r.table('marvel').get('IronMan').do(\n  lambda ironman: r.branch(ironman['victories'] < ironman['battles'],\n                            r.error('impossible code path'),\n                            ironman)\n).run(conn)"
# r expr
rethinkdb.expr.__doc__ = u"Construct a RQL JSON object from a native object.\n\nObjects wrapped with expr can then be manipulated by RQL API functions.\n>>> r.expr({'a':'b'}).merge({'b':[1,2,3]}).run(conn)"
# value default
rethinkdb.ast.RqlQuery.default.__func__.__doc__ = u"Handle non-existence errors.  Tries to evaluate and return its first argument.  If an error related to the absence of a value is thrown in the process, or if its first argument returns null, returns its second argument.  (Alternatively, the second argument may be a function which will be called with either the text of the non-existence error or null.)\n\nStark Industries made the mistake of trusting an intern with data entry, and now a bunch of fields are missing from some of their documents.  Iron Man takes a break from fighting Mandarin to write some safe analytics queries.\n>>> r.table('projects').map(\n  lambda p: p['staff'].default(0) + p['management'].default(0)\n).run(conn)"
# r js
rethinkdb.js.__doc__ = u'Create a javascript expression.\n\nConcatenate two strings using Javascript\'\n>>> r.js("\'str1\' + \'str2\'").run(conn)\n\nSelect all documents where the \'magazines\' field is greater than 5 by running Javascript on the server.\n>>> r.table(\'marvel\').filter(\n  r.js(\'(function (row) { return row.magazines > 5; })\')).run(conn)\n\nYou may also specify a timeout in seconds (defaults to 5).\n>>> r.js(\'while(true) {}\', timeout=1.3).run(conn)'
# sequence coerce_to
rethinkdb.ast.RqlQuery.coerce_to.__func__.__doc__ = u"Converts a value of one type into another. <br /><br />\nYou can convert: a selection, sequence, or object into an ARRAY, \nan array of pairs into an OBJECT, and any DATUM into a STRING.\n\n\nConvert a table to an array.\n>>> r.table('marvel').coerce_to('array').run(conn)\n\nConvert an array of pairs into an object.\n>>> r.expr([['name', 'Ironman'], ['victories', 2000]]).coerce_to('object').run(conn)\n\nConvert a number to a string.\n>>> r.expr(1).coerce_to('string').run(conn)"
# any type_of
rethinkdb.ast.RqlQuery.type_of.__func__.__doc__ = u'Gets the type of a value.\n\nGet the type of a string.\n>>> r.expr("foo").type_of().run(conn)'
# any info
rethinkdb.ast.RqlQuery.info.__func__.__doc__ = u"Get information about a RQL value.\n\nGet information about a table such as primary key, or cache size.\n\n>>> r.table('marvel').info().run(conn)"
# r json
rethinkdb.json.__func__.__doc__ = u'Parse a JSON string on the server.\n\nSend an array to the server\'\n>>> r.json("[1,2,3]").run(conn)'
